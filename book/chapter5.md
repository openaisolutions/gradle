## Part IV – Aligning Configurations for Compilation, Execution and Publishing

After untangling the monolith’s packages and redefining modules, the next challenge is to ensure that every module can be compiled, run and published consistently.  Gradle provides a rich set of dependency configurations—`api`, `implementation`, `compileOnly`, `runtimeOnly` and their test variants—that allow you to declare precisely how and when dependencies are used.  Correct use of these configurations not only shortens the compile classpath and reduces recompilations but also ensures that published POM files accurately represent your module’s API【21875673602686†L325-L352】.  This part of the book explains each configuration, maps them to Maven scopes, and demonstrates how to run applications and assemble distributions.  By aligning configurations across development, testing and publishing, you build confidence that your modules behave the same in every environment.

### Chapter 5: Compile, Run, Publish – Aligning Gradle Configurations for All Worlds

Migration is not complete until your build produces artifacts that can be consumed by other projects, run on developer machines and deployed in production.  This chapter dives into Gradle’s dependency configurations, explains the differences between `api` and `implementation`, shows how to use `compileOnly` and `runtimeOnly`, and illustrates how to run applications and assemble distributions.  We also cover mapping Gradle configurations to Maven scopes and highlight best practices to avoid dependency leaks.

#### Section 1: From `compile` to `api` and `implementation`

In older Gradle versions all dependencies were declared in the `compile` configuration, which placed them on both the compile and runtime classpaths.  Gradle 5.0 removed `compile` in favour of `api` and `implementation` configurations provided by the Java Library plugin【21875673602686†L325-L352】.  Dependencies declared with `api` are exposed to consumers; they appear on the compile classpath of any project that depends on your module and are listed in its POM【21875673602686†L325-L352】.  `implementation` dependencies, by contrast, remain internal: they are on your compile and runtime classpaths but are not exposed to consumers.  This separation reduces the number of classes on downstream classpaths, decreases recompilation and prevents accidental reliance on internal types【21875673602686†L349-L361】.  When migrating from `compile`, start by applying the `java-library` plugin and moving existing dependencies into `api` or `implementation` based on whether they appear in your public API.

#### Section 2: Understanding API and Implementation Separation

The Java Library plugin formalises the concept of an API.  A module’s API comprises types that appear in public or protected method signatures, superclass and interface declarations, public fields and annotations【21875673602686†L325-L352】【21875673602686†L410-L417】.  Dependencies required to compile these types should be declared using `api` so they are available to consumers.  All other types—those used exclusively in method bodies, private members or internal classes—belong to the `implementation` configuration【21875673602686†L425-L433】.  Following this rule ensures that your module’s consumers do not inadvertently depend on transitive implementation details.  When in doubt, prefer `implementation` and promote to `api` only when the compiler complains.  The separation also improves incremental compilation: if an `implementation` dependency changes, only the modules that directly depend on it are recompiled【21875673602686†L355-L361】.

#### Section 3: Using `compileOnly` for Provided Dependencies

Some dependencies are needed only at compile time.  The Gradle blog introducing compile‑only dependencies explains that `compileOnly` behaves similarly to Maven’s provided scope: it allows you to declare non‑transitive dependencies used only at compilation【121253874567365†L109-L125】.  These dependencies are not included on the runtime classpath and are omitted from published metadata【121253874567365†L127-L132】.  Typical examples include annotation processors like Lombok or servlet APIs provided by the application server.  The article notes that compile‑only dependencies continue to work with Gradle’s IDEA and Eclipse plugins and are mapped to the corresponding “provided” scope in IDEs【121253874567365†L134-L137】.  Declaring a compile‑only dependency is straightforward.  When using `compileOnly`, ensure that the dependency truly is provided by the runtime environment; otherwise the application may fail to start.

#### Section 4: Declaring `runtimeOnly` Dependencies

Conversely, some dependencies are needed only at runtime.  The Gradle user guide defines the `runtimeOnly` configuration as “dependencies needed only at runtime, not included in the compile classpath”【904821515729589†L357-L360】.  Examples include logging implementations like Logback or database drivers loaded via reflection.  When you declare a `runtimeOnly` dependency, it will appear on the runtime classpath but not on the compile classpath.  This separation keeps the compile classpath lean and speeds up compilation.  In a multi‑project build you can run the `dependencies` task with the `--configuration runtimeOnly` flag to see which dependencies are included【904821515729589†L447-L456】.  Be careful not to place classes used in method signatures into `runtimeOnly`; doing so will cause compilation errors.

#### Section 5: Test Configurations – `testImplementation` and `testCompileOnly`

Gradle provides analogous configurations for tests.  The `testImplementation` configuration includes dependencies required to compile and run your tests【904821515729589†L363-L366】.  This is where you declare libraries such as JUnit, Mockito or AssertJ.  If a dependency is only needed to compile your tests but should not be present at test runtime—for example, an annotation processor—you can use `testCompileOnly`【904821515729589†L369-L372】.  Similarly, `testRuntimeOnly` is available for dependencies needed only when executing tests【904821515729589†L373-L377】.  Using the appropriate test configurations ensures that your test classpaths mirror your production classpaths, helping you catch missing dependencies early.

#### Section 6: Mapping Configurations to Maven Scopes

When publishing a module to Maven, Gradle translates its configurations into Maven scopes.  The Java Library plugin ensures that dependencies in the `api` configuration are mapped to the Maven `compile` scope, while those in `implementation` become `runtime` scope【21875673602686†L349-L367】.  Dependencies in `runtimeOnly` are likewise placed in the Maven `runtime` scope, and `compileOnly` dependencies are omitted from the POM entirely【904821515729589†L344-L360】.  This mapping prevents consumers from accidentally depending on your implementation dependencies and matches Maven’s semantics.  If a third‑party library published with Maven does not follow these conventions, you can apply a component metadata rule to fix incorrect scopes【21875673602686†L369-L387】.  Understanding how Gradle translates configurations helps you avoid dependency confusion when mixing Gradle and Maven projects.

#### Section 7: Ensuring IDE Compatibility

Proper configuration also improves IDE integration.  The compile‑only blog emphasises that `compileOnly` dependencies continue to work with Gradle’s IDEA and Eclipse plug‑ins and are mapped to the IDE’s provided scope【121253874567365†L134-L137】.  Buildship and IntelliJ read the `api` and `implementation` configurations and place dependencies on the correct classpaths.  If you misuse configurations—for example, declaring an annotation processor in `implementation`—the IDE may add it to the runtime classpath, masking missing dependencies and slowing down compilation.  We recommend re‑importing your project after modifying dependency declarations and using the IDE’s Gradle view to inspect the classpath.  When issues arise, run `./gradlew dependencies` with the appropriate configuration and compare the output to what the IDE displays.

#### Section 8: Guidelines for Choosing the Right Configuration

Selecting the appropriate configuration becomes easier with a few rules of thumb.  Prefer `implementation` for most dependencies; this keeps them off the consumer’s compile classpath and reduces recompilation【21875673602686†L349-L361】.  Use `api` only when a type appears in your public API【21875673602686†L325-L352】.  Declare dependencies required only at compile time as `compileOnly`【121253874567365†L109-L125】 and those required only at runtime as `runtimeOnly`【904821515729589†L357-L360】.  For test code, mirror these choices with `testImplementation`, `testCompileOnly` and `testRuntimeOnly`.  When integrating plugins, read their documentation to determine which configuration to use.  Following these guidelines will result in cleaner builds and more predictable behaviour.

#### Section 9: Running Applications with the Application Plugin

The application plugin makes it easy to run JVM applications locally and to package them as distributions.  It implicitly applies the Java and distribution plugins and adds a `run` task that executes the main class specified in your build script【97055485946526†L291-L350】.  You can run your application with `./gradlew run` or launch it in debug mode using the `--debug-jvm` flag【97055485946526†L291-L350】.  The plugin also generates start scripts for Unix and Windows and assembles a ZIP or TAR distribution containing your JAR and runtime dependencies.  When combined with proper dependency configurations, the application plugin ensures that only `implementation` and `runtimeOnly` dependencies are packaged, keeping the distribution lean.

#### Section 10: Customising Run Tasks and JVM Arguments

Beyond the default `run` task, you can customise how your application starts.  The application plugin allows you to pass program arguments at the command line using the `--args` option and to set default JVM options through the `application` extension【97055485946526†L353-L377】.  You can also change the directory where start scripts are generated by setting the `executableDir` property【97055485946526†L353-L377】.  These options let you align local runs with production settings and pass configuration values via environment variables or project properties.  For debugging, combine `--debug-jvm` with your IDE’s remote debugging capabilities to attach breakpoints and inspect program state.

#### Section 11: Managing Resources and Source Sets

Gradle’s source set abstraction not only groups Java sources but also manages non‑Java resources. Each source set has a `resources` directory that defaults to `src/<sourceSet.name>/resources`【429035147424465†L486-L492】. Files in this directory—properties files, XML descriptors, images, etc.—are automatically copied into the resources output directory and included on the runtime classpath【429035147424465†L486-L492】. You can customise resource handling by configuring the `resources` block on a source set. For example, you might exclude `*.bak` files or relocate configuration files into a subdirectory of the JAR. When adding new source sets (for example, to support integration tests or alternative build profiles), remember to declare both `java` and `resources` directories so that Gradle knows where to find code and resources. To avoid surprising behaviour, maintain a clean separation between production and test resources and avoid placing resources in the Java source directory.

#### Section 12: Assembling Distributions and Installers

Beyond running your application, you often need to distribute it to users or deploy it on servers. The **distribution plugin** works alongside the application plugin to create ZIP and TAR archives containing your JAR and its runtime dependencies. The user guide explains that `distZip` packages the main distribution as a ZIP, `distTar` creates a TAR file, and `assembleDist` depends on both to build both types of archives【28819602868581†L327-L351】. Running `installDist` assembles an uncompressed directory under `build/install/<project>`【28819602868581†L327-L356】. You can add additional distributions, such as a “lite” package without documentation or a “full” package with extra plugins. Gradle adds tasks like `customDistZip`, `customDistTar`, `assembleCustomDist` and `installCustomDist` for each extra distribution【28819602868581†L357-L377】. To include additional files, place them in `src/<distribution>/dist` or configure the `contents` block to copy files from other directories【28819602868581†L411-L445】. Install4j or jpackage can build platform‑specific installers, but the distribution plugin provides a cross‑platform baseline.

#### Section 13: Publishing Libraries

When your module becomes a reusable library, you need to publish it to a repository so others can depend on it. Gradle’s **maven‑publish** plugin simplifies this process. Applying the plugin adds a `publishing` extension that contains a container of `publications` and a container of `repositories`【800041472511575†L318-L322】. The plugin registers tasks such as `generatePomFileFor<Publication>`, which creates a POM containing your module’s metadata and dependencies【800041472511575†L324-L333】, and `publish<Publication>PublicationTo<Repo>` tasks that publish artifacts to remote repositories【800041472511575†L333-L350】. The `publishToMavenLocal` task publishes all defined publications to your local Maven cache【800041472511575†L339-L356】. To publish a Java component, create a `MavenPublication` and specify the component via `from(components["java"])`【800041472511575†L292-L321】. You can override the default `groupId`, `artifactId` and `version` and customise the POM with information like name, description, URL, licences and SCM coordinates【800041472511575†L292-L321】. Publishing ensures that your dependency configurations (`api`, `implementation`, etc.) are reflected correctly in the resulting metadata, avoiding classpath pollution for consumers.

#### Section 14: Configuring Different Runtime Profiles

Real‑world applications often run in multiple environments—development, staging, production—with different runtime requirements. Gradle makes it easy to define multiple runtime profiles using separate source sets, resource directories and dependency configurations. For example, you can create a `src/dev/java` and `src/dev/resources` directory and a corresponding `dev` source set that depends on the main code. Within `devImplementation` and `devRuntimeOnly` configurations you can declare dependencies such as embedded databases or debugging tools that should never reach production. When packaging the application, use `./gradlew installDist -Pprofile=dev` to select the appropriate profile. Similar techniques apply to Android product flavours and build variants. Keep environment‑specific logic out of your main codebase by externalising configuration values into property files and environment variables. These patterns reduce the risk of deploying development dependencies into production and allow you to test configuration changes without recompiling your code.

#### Section 15: Handling Optional and Transitive Dependencies

Dependency management becomes tricky when you need to support optional features or manage transitive dependencies. Gradle provides several tools to cope. Declaring a dependency as `compileOnly` or `runtimeOnly` marks it as non‑transitive and excludes it from published metadata【121253874567365†L109-L125】【904821515729589†L357-L360】. Clients must add the dependency explicitly to use optional functionality. For transitive dependencies pulled in by libraries, use dependency constraints or version alignment to control versions across all modules【613331523443752†L298-L339】. You can also exclude specific transitive dependencies from a given declaration to prevent conflicts. For example:

```
dependencies {
    implementation('org.hibernate:hibernate-core') {
        exclude group: 'org.jboss.logging'
    }
    constraints {
        implementation('org.jboss.logging:jboss-logging:3.5.1.Final')
    }
}
```

This excludes the version of `jboss-logging` bundled with Hibernate and replaces it with a consistent version across the build. Document optional dependencies in your module’s README so that consumers know when to add them.

#### Section 16: Using BOMs and Dependency Constraints

As a project grows, keeping dependency versions consistent across modules becomes challenging. Gradle’s **platform** and **dependency constraints** features solve this problem. A platform is a special project that declares version constraints in its `dependencies { constraints { ... } }` block【613331523443752†L298-L327】. By applying the `java-platform` plugin and declaring constraints with `api(...)` and `runtime(...)`, you centralise version definitions; any module that depends on the platform will use the specified versions【613331523443752†L298-L327】. Dependency constraints can also be declared alongside dependencies to force a minimum or fixed version【613331523443752†L343-L357】. When Gradle resolves modules, it considers these constraints together with transitive dependencies and selects a version that satisfies all requirements【613331523443752†L349-L352】. Publishing constraints requires Gradle module metadata; when consuming libraries from Maven, only declared dependencies are honoured【613331523443752†L474-L477】. Using platforms and constraints reduces version drift, improves build reproducibility and simplifies upgrades.

#### Section 17: Building Executable and Fat JARs

Packaging an application into a single executable JAR (often called a “fat JAR” or “uber JAR”) can simplify deployment, especially for microservices. While Gradle does not provide a built‑in fat‑JAR plugin, several community plugins—such as the Shadow plugin—bundle your code and all runtime dependencies into one archive. To create an executable JAR without third‑party plugins, you can configure the `jar` task to set the `Main-Class` attribute in the manifest and use the `runtimeClasspath` configuration to copy dependencies into a `lib` directory within the distribution. When combined with the distribution plugin, this approach produces a self‑contained archive that can be executed with a simple `java -jar`. Be mindful of licensing when repackaging third‑party libraries and consider whether building a Docker image or using the application plugin’s start scripts better suits your deployment environment.

#### Section 18: Modules and the Java Platform Module System (JPMS)

Java 9 introduced the Java Platform Module System (JPMS), which provides strong encapsulation and reliable configuration. Migrating a large codebase to modules is a long‑term effort, but Gradle supports it incrementally. Each module should contain a `module-info.java` file that declares its dependencies and exported packages. Gradle automatically compiles `module-info.java` when placed alongside your Java sources and passes the `--module-path` and `--patch-module` options to `javac`. When building a multi‑project JPMS application, ensure that each subproject has a unique module name and avoid split packages. Tools like the `java-library` plugin combined with the `modularity` plugin or the `gradle-modules-plugin` can help configure the module path and run tests on the module path. Although JPMS adoption is optional for most projects, modularising your code can improve encapsulation and lay the groundwork for migrating to the `jlink` or `jpackage` tools for creating custom runtime images.

#### Section 19: Continuous Integration and Verification

Dependency configuration is only as good as the verification you perform. CI pipelines should run tasks that verify your dependency graph and catch issues early. Use `./gradlew dependencies` and `./gradlew dependencyInsight` to visualise how dependencies are resolved and identify version conflicts【814383946455057†L302-L311】. The `dependencyInsight` task pinpoints which dependency path pulled in a particular module, helping you understand transitive dependencies【814383946455057†L347-L356】. Combine these reports with build scans to capture complete build metadata and share it with team members; build scans provide web‑based visualisations and deep diagnostics【856209582615570†L156-L168】. Integrate these tasks into your CI pipeline and fail the build on unresolved or version‑conflicting dependencies. Automating verification gives you confidence that your published artifacts are consistent and your build remains reproducible over time.

#### Section 20: Summary and Looking Ahead

This chapter has explored how proper dependency configuration, resource management, distribution packaging and publishing practices enable your modules to compile, run and be consumed reliably. You learned the differences between `api`, `implementation`, `compileOnly` and `runtimeOnly`, how to map them to Maven scopes and how to avoid leaking implementation details【21875673602686†L325-L352】【21875673602686†L349-L361】. We discussed using the application and distribution plugins to run applications locally and package them for distribution【28819602868581†L327-L356】, and we covered publishing libraries to Maven repositories using the maven‑publish plugin【800041472511575†L318-L322】. Finally, we looked at advanced topics like runtime profiles, optional dependencies, BOMs and the Java module system. In the next chapter, we turn our attention to the build itself as an expression of architecture: we will manage source sets, BOMs and plugins to enforce conventions and encode architectural decisions.