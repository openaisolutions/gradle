## Part VI – From Chaos to Convention – Naming, Packaging, and Zipping Everything

As you modularize a legacy system, the packaging and naming conventions you adopt become just as important as the code itself.  Inconsistent names, ad‑hoc folder structures and home‑grown distribution scripts were tolerated in the Ant/SVN era, but a modular Gradle monorepo demands clarity and repeatability.  This chapter shows how to bring order to packaging by following widely accepted naming conventions, using Gradle’s distribution plug‑in to assemble archives, bundling resources and runtime components, and building CI pipelines that produce verifiable, cross‑platform installers.  Good packaging practices not only make releases predictable; they also help consumers understand what each module does and how to use it.  By the end of this chapter you will have a playbook for delivering cleanly named artifacts and installers that work on any machine.

### Chapter 7: From Chaos to Convention – Naming, Packaging, and Zipping Everything

#### Section 1: Naming Conventions for Modules and Packages

Before worrying about how to zip your code, agree on what to call it.  When you publish libraries or applications, the Maven‐style coordinates—`groupId`, `artifactId` and `version`—identify your artifact uniquely.  Maven’s naming guide recommends that a project’s `groupId` follow Java package naming rules, using your reversed domain name to avoid clashes【477992074245371†L113-L119】.  For example, an organisation `com.example` might choose a `groupId` like `com.example.platform`.  The `artifactId` should consist only of lowercase letters, digits and hyphens and reflect the module’s purpose【477992074245371†L146-L152】.  In a modular monolith, adopt a convention where the top‑level module names correspond to business capabilities (e.g., `inventory-service`, `billing-api`) and submodules to technical layers.  Consistent naming improves comprehension, eases browsing in IDEs and ensures that artifact file names (`artifactId-version.jar`) are meaningful.

#### Section 2: Setting Up Standard Distribution Directories

Gradle expects your code and resources to live in predictable locations.  For packaging, the Java library distribution plug‑in copies everything in `src/main/dist` into the root of the archive【565790034406687†L335-L337】.  Create this directory in each module and place configuration files, scripts and documentation that should accompany your JAR.  To organise resources logically, mirror the runtime structure: use `src/main/dist/bin` for shell scripts and `src/main/dist/config` for default configuration files.  Keeping packaging files alongside source code allows them to evolve together and makes it obvious which files will appear in the distribution.  During the migration from Ant, we created `src/main/dist` folders for each module and moved the previously hand‑assembled artefacts into them.

#### Section 3: Understanding the Distribution Plug‑in

Gradle’s distribution plug‑in takes the tedium out of assembling archives.  Once applied, it adds tasks such as `distZip` and `distTar` to package your project as ZIP or TAR archives【28819602868581†L327-L351】.  Running `gradle distZip` creates a ZIP file at `build/distributions/<project>-<version>.zip`, while `gradle distTar` produces a TAR file.  The `assembleDist` task depends on both and builds all configured distributions【28819602868581†L347-L351】.  For quick local testing you can invoke `installDist`, which copies the distribution into `build/install/<project>`【28819602868581†L332-L356】.  These tasks work out of the box with sensible defaults and respect your project’s version and name.  They replace hand‑written Ant scripts and guarantee that every distribution contains the same set of files.

#### Section 4: Customising Distribution Names and Classifiers

Sometimes you need your archive names to differ from the default `<project>-<version>`.  The distribution plug‑in allows you to set `distributionBaseName` and `distributionClassifier` properties on the `main` distribution to override the base name and add a classifier.  The user guide shows that setting `distributionBaseName = 'someName'` and `distributionClassifier = 'classifier'` changes the generated file names【28819602868581†L421-L449】.  For example, a `billing-api` module with version `1.0` could be packaged as `billing-api-runtime-1.0.zip`.  Use classifiers to distinguish between runtime distributions, sources, documentation or different JDK flavours.  Encoding this information into the filename makes it clear which archive to download without inspecting its contents.

#### Section 5: Including Additional Files in the Distribution

The default distribution includes the JAR and runtime dependencies, but you often need to bundle extra resources.  You can do this declaratively using the `contents` block of the `distributions` configuration.  The manual illustrates adding directories into specific paths within the archive—for example, copying a `config` directory into `bin/config` and a `samples` folder into `lib/samples`【28819602868581†L447-L490】.  These `CopySpec` instructions create the necessary directories and populate them with your files.  Combine this with `from('src/main/dist')` to include all files you placed under `src/main/dist`.  When migrating from Ant, we replaced custom copy tasks with these declarative rules, ensuring the same logic works in both Groovy and Kotlin DSLs.

#### Section 6: Creating Additional Distributions

Large applications may need multiple flavours of distribution.  The distribution plug‑in supports this by letting you add named distributions.  The guide explains that creating a distribution called `custom` adds tasks such as `customDistZip`, `customDistTar`, `assembleCustomDist` and `installCustomDist`【28819602868581†L357-L381】.  You can configure each distribution separately, specifying its own `distributionBaseName`, classifier and contents.  For example, a multi‑tier application might have a `server` distribution that bundles the backend and a `client` distribution with only the frontend assets.  Additional distributions are a clean way to produce environment‑specific bundles without resorting to conditional logic scattered throughout the build.

#### Section 7: Packaging Plug‑in Modules Separately

Our project relies on plug‑ins such as PF4J modules that extend the application.  Each plug‑in should be packaged independently so that it can be updated or replaced without touching the core.  To achieve this, we treat each plug‑in as its own Gradle project and apply the distribution plug‑in.  Then we configure the distribution to include only the plug‑in JAR and its runtime dependencies.  Naming conventions help consumers identify these plug‑ins: we suffix the artifactId with `-plugin` and set the classifier to the target platform.  This approach mirrors the recommended practice from the Gradle community: plug‑ins are published as separate artifacts with their own metadata, making dependencies explicit and easing version management.

#### Section 8: Bundling a JRE and Using jpackage

Java applications often require a specific Java runtime.  While Oracle’s binary licence restricts redistributing their JRE, you can bundle OpenJDK runtimes using tools like **jpackage**.  Gradle does not yet provide a built‑in jpackage plug‑in, but third‑party plugins like `org.beryx.jlink` and `org.panteleyev.jpackageplugin` automate packaging.  These plugins download the appropriate JDK, link modules and produce platform‑specific installers (MSI, DMG and DEB).  Alternatively, commercial tools like Install4j integrate with Gradle to create native installers and allow bundling a JRE【434703612789846†L780-L931】.  When choosing a packaging approach, consider licensing, update strategy and the target platforms.  For our migration, we used the jlink plug‑in to produce a small runtime containing only the required modules and distributed it alongside our application using Gradle’s distribution plug‑in.

#### Section 9: Generating SBOM and BOM Files

Modern software supply‑chain security requires publishing bill of materials (BOM) files and software bills of materials (SBOM).  A BOM (often created using the `java-platform` plug‑in) centralises dependency versions and ensures that all modules use consistent versions.  The dependency constraints documentation shows how to define version constraints and publish them with Gradle module metadata【613331523443752†L298-L339】.  For security, you can generate an SBOM in CycloneDX format using the CycloneDX Gradle plug‑in, which aggregates all direct and transitive dependencies into a JSON or XML document【247288069817800†L52-L79】.  We configure our build to produce both files during `assembleDist`, storing them under `META-INF` in the distribution.  Publishing these artifacts helps consumers verify that no vulnerable dependencies slip into the release.

#### Section 10: Building CI Pipelines for Packaging

Packaging does not end at the developer’s machine; it must be automated in continuous integration.  Configure your CI server to run `./gradlew clean assembleDist` on every tag or release branch.  Store generated ZIPs and TARs as build artifacts and publish them to your repository manager.  Include tasks that run `check` to verify static analysis and tests before packaging.  Because packaging tasks depend on your compiled classes and resources, the CI pipeline surfaces build failures early.  For multiplatform applications, run packaging on all target operating systems or use containerised runners to produce platform‑specific installers.  After packaging, generate and upload SBOM and BOM files, then sign the archives if required by your release policy.

#### Section 11: Handling Platform‑Specific Packaging

Different operating systems have different expectations for launchers and installation.  Gradle’s distribution plug‑in produces generic archives, but tools like jpackage or Install4j can create native installers.  On Windows, installers often include a service wrapper and registry entries; on macOS, applications are packaged as `.dmg` or `.pkg` files with proper entitlements; on Linux, `.deb` or `.rpm` packages integrate with the system’s package manager.  When bundling a JRE, ensure that the runtime matches the target architecture (x64 vs ARM).  Use classifiers to name your archives accordingly (e.g., `app-1.0-windows-x64.zip`), and document which installers support which platforms.  Test each installer in a clean VM to verify installation, uninstallation and upgrades.

#### Section 12: Publishing Distributions to Repositories

Once you have built your ZIP and TAR files, publish them alongside your libraries.  The distribution plug‑in can integrate with the `maven-publish` plug‑in: simply add the archive tasks as artifacts to a `MavenPublication`.  The user guide demonstrates publishing a distribution by referencing `tasks.distZip` and `tasks["customDistTar"]` within the `publishing` block【28819602868581†L503-L545】.  This approach uploads your distribution archives to a Maven or Ivy repository and allows consumers to retrieve them with dependency coordinates.  When publishing, set a clear `artifactId` and classifier so that tools like Gradle can select the appropriate artifact automatically.

#### Section 13: Managing Checksums and Signing

Package consumers need assurance that archives have not been tampered with.  Generate cryptographic checksums (SHA‑256 or SHA‑512) for each ZIP and TAR and publish them alongside the archives.  Many repository managers can automatically calculate checksums, but generating them in the build provides reproducibility.  If your organisation requires signing, use the `signing` plug‑in to create `.asc` signatures for each artifact and attach them to your publication.  Signing proves that the artifact came from a trusted source and that it hasn’t been modified.  Document your signing keys and rotation policies in your release process.

#### Section 14: Aligning Versions and Release Management

Proper versioning communicates compatibility and progress.  Follow semantic versioning: increment the major version for incompatible API changes, the minor version for backwards‑compatible feature additions and the patch version for bug fixes【477992074245371†L156-L170】.  For pre‑releases use suffixes such as `-beta` or `-rc1`【477992074245371†L172-L177】.  In a multi‑module monorepo, align version numbers across modules when they represent a single release train.  Use Gradle’s version catalog or a central `gradle.properties` file to define the version once.  Automate version bumps via release scripts and include the version in your distribution file names.  For long‑running feature branches, append a build metadata string to differentiate snapshots.  Consistent versioning makes it easier to correlate artifacts with source code and track which features shipped when.

#### Section 15: Documenting the Distribution Layout

When users unpack your distribution they should know where to find executables, libraries and configuration.  Provide a `README.md` in the root of the distribution that describes the directory structure and how to run the application.  For example, document that scripts live in `bin`, libraries in `lib`, configuration files in `config` and sample data in `samples`.  Include information about required environment variables and how to upgrade.  If you provide multiple distributions (client/server, different JDKs), list them and explain when to use each.  Good documentation reduces support tickets and builds trust in your release process.

#### Section 16: Avoiding Packaging Pitfalls

Packaging mistakes can derail a release.  One common problem is including unnecessary transitive dependencies, which bloat the archive and create licensing issues.  Use the `dependencies` and `dependencyInsight` tasks to audit your runtime classpath and exclude unwanted modules.  Another pitfall is forgetting to mark internal modules as `implementation` or `runtimeOnly`, causing them to leak into the distribution.  Review your `dependencies` declarations and ensure that only public APIs are exposed【21875673602686†L325-L361】.  Finally, test your distributions offline to ensure they contain all required resources; a common error is missing resource files because they were stored outside the configured `dist` directory.

#### Section 17: Case Study – Packaging a Modular Monolith

To illustrate these concepts, consider our billing application composed of eight Gradle modules.  Each module applies the Java library plug‑in; one module (`billing-app`) also applies the application plug‑in and distribution plug‑in.  We defined a `server` distribution for the app and a `plugins` distribution for optional PF4J plug‑ins.  In `billing-app` we set `distributionBaseName = 'billing-app'` and added `applicationDefaultJvmArgs` to configure the JVM.  For the `plugins` distribution we included only plug‑in JARs and generated a `plugins.txt` file listing available extensions.  Our CI pipeline produces `billing-app-1.0.zip` and `billing-plugins-1.0.zip`, publishes them to our Nexus repository, attaches checksums and SBOMs and notifies the team.  This approach allows operations teams to deploy the application and plug‑ins independently and ensures that all runtime components are accounted for.

#### Section 18: Testing Installers and Distributions

After packaging, verify that your installers work as expected.  Write automated tests that unpack each archive, run the application, and assert that it starts successfully.  On Windows, use PowerShell scripts to execute the `.bat` launchers; on Unix, use Bash.  Test upgrade scenarios by installing an older version, then installing the new one over it.  For jpackage installers, test installation on the supported operating systems to ensure desktop integrations (shortcuts, start menu entries) are created.  If you bundle a JRE, validate that the correct Java version is used and that environment variables like `JAVA_HOME` are ignored.  Include these tests in your CI pipeline so that packaging failures are caught early.

#### Section 19: Migrating Packaging from Ant to Gradle

Legacy Ant scripts often assemble distributions by copying files manually into a staging directory and then zipping them.  Gradle’s distribution plug‑in lets you replace these imperative scripts with declarative configuration.  Begin by identifying the inputs of the Ant packaging: compiled classes, libraries, configuration files and scripts.  Move those files into `src/main/dist` and configure the `contents` block accordingly【565790034406687†L335-L337】.  Then run `gradle distZip` and compare the output with the Ant zip.  Gradle’s migration guide recommends keeping both builds side by side and verifying that outputs match before deleting the Ant script【495392568104378†L356-L371】.  Once verified, remove the Ant build and rely solely on the distribution plug‑in.

#### Section 20: Summary and Looking Ahead

Naming and packaging are the public face of your software.  Consistent coordinates, clear distribution layouts and reproducible archives send a message of professionalism and reliability.  By leveraging Gradle’s distribution plug‑in you eliminate bespoke packaging scripts and create standard tasks (`distZip`, `assembleDist`, `installDist`) that anyone can run【28819602868581†L327-L351】.  Customising distribution names and contents gives you flexibility without sacrificing structure【28819602868581†L421-L449】.  Generating BOMs and SBOMs enhances supply chain transparency【613331523443752†L298-L339】【247288069817800†L52-L79】, while CI automation ensures that packaging remains consistent over time.  In the next chapter we will dive into the complexities of publishing modules to Maven repositories and explore how to generate POMs that accurately reflect your dependencies and scopes.